program simnet (input,output,plotfil);    const    runname = ' population based load';   maxclock = 300.0;    maxnode = 175;   maxpath = 9;   maxlevel = 3;    maxorder = 9;    maxcity = 20;    maxdelay = 255;    maxcounter = 50;  (* graph *)    maxcolumn = 100;   maxxscat = 100;  (* scatter *)   maxyscat = 50;   waittime = 0.50;  (* xmit scheduleing parameters *)    xmittime = 0.13;   queuelimit = 2000;  (* node buffer limit *)    lastarrival = 240.0;  (* load specifications *)    interarrival = 20.0;   arrivaltime = 2.0;   dynamic = true;  (* load dependent routing *)    linked = false;  (* trans-con link *)   popbased = true;  (* population based routing *)   plotting = true;  (* message plot *)   type   nodenum = 1..maxnode;    routevector = array [1..maxorder] of nodenum;   delayvector = array [1..maxorder] of 0..maxdelay;   eventname = (arrival,xmit,sample,update);    zipcode = array [1..maxlevel] of 1..maxorder;   cityname = array [1..maxcity] of char;    blocktype = (eventblock,msgblock);   title = array [1..20] of char;       link = ^block;      block =  (* unit of dynamic data structure *)      record       next: link;  (* forward links only *)        case blocktype of          eventblock: (            timex: real;  (* time of event *)            name: eventname;  (* kind of event *)            node: nodenum);  (* object of event *)         msgblock: (            track: boolean;  (* path tracking *)           destzip: zipcode;  (* destination *)           hopcount: 0..500;            queued: real;  (* received time *)           start: real)  (* start time *)     end;      graph =  (* histogram data *)      record       maximum: real;       count: integer;        highest, sum, sumsq: real;       counter: array [0..maxcounter] of integer;     end;      scatter =  (* scattergram data *)      record       sumx, sumy: real;        count: integer;        xinc, yinc: real;        marks: array [0..maxxscat] of          array [0..maxyscat] of boolean;     end;    var    plotfil: text;  (* trace output for plot *)  lastnode: nodenum;  (* true number of nodes in network *)    s: array [nodenum] of      record       lastpath: 1..maxpath;  (* connectivity *)        path: array [1..maxpath] of nodenum;  (* specific connections *)       zip: zipcode;  (* this stations routing code *)        route: array [1..maxlevel] of routevector;  (* routing tables *)       delay,       promise: array [1..maxlevel] of delayvector;       updating: boolean;  (* update in progress flag *)        nextmsg,       lastmsg: link;  (* message queue pointers *)       queuelength: integer;  (* number in message queue *)       usecount: integer;  (* message count for utilization *)        usetime: real;  (* time using or waiting to use channel *)       city: cityname;  (* unique city name *)        tracing: boolean;  (* debug output flag *)       population: integer;  (* population in thousands *)        latatude,      longitude: integer;  (* location *)      displacement: -3 .. 3;  (* ledgend tweek for map *)    end;      retrys,    queuetime,   transittime,   hops: graph;      queueing,    backlog,   routing,   delivery: scatter;      clock: real;  (* simulated time *)      meanpop,   totalpop: integer;   (* mean and total population *)      eventcount,    msgcount,    updatecount: integer;  (* sample statistics *)   lastnew: link;  (* low limit of heap *)       trace:  (* debug trace flags *)      record       tables,       events,        samples,       messages: boolean;     end;       procedure readinput;  (* initialize station data *)    const      ny = 10;  (* new york *)     sf = 169;  (* san fransisco *)   var i, j: integer;   begin (* readinput *)      totalpop := 0;     while not eof (input) do     begin  (* read one station *)        read (lastnode);       with s [lastnode] do       begin          for i := 1 to maxcity do read (city [i]);         for i := 1 to maxlevel do read (zip [i]);         readln (population, latatude, longitude, displacement);         longitude := - longitude;        totalpop := totalpop + population;         for i := 1 to maxpath do         begin            read (path [i]);           if path [i] <> 0 then lastpath := i;         end;         readln;          for i := 1 to maxlevel do          begin            for j := 1 to maxorder do            begin              read (route [i][j]);             delay [i][j] := 0;              promise [i][j] := 0;            end;           readln;          end;         nextmsg := nil;          updating := false;         queuelength := 0;          usecount := 0;         usetime := 0.0;          tracing := false;        end (* with *)     end; (* while *)     meanpop := round (totalpop / lastnode);      if linked then     begin        with s [ny] do       begin lastpath := lastpath + 1; path [lastpath] := sf; end;        with s [sf] do       begin lastpath := lastpath + 1; path [lastpath] := ny; end;      end;   end; (* readinput *)         function limit (r: real; max: integer): integer;     var        i: integer;      begin        i := round (r);        if i < 0 then i := 0       else         if i > max then i := max;        limit := i;      end;         procedure preset (var g: graph; m: real);      var i: 0..maxcounter;      begin        g.maximum := m;        g.count := 0;        g.sum := 0.0;        g.sumsq := 0.0;        g.highest := 0.0;        for i := 0 to maxcounter do g.counter [i] := 0;      end; (* preset *)          procedure count (item:real; var g:graph);      var i: integer;      begin        with g do          begin            count := count + 1;            sum := sum + item;           sumsq := sumsq + item*item;            if item > highest then highest := item;            i := limit (item/maximum*maxcounter, maxcounter);            counter [i] := counter [i] + 1;          end; (* with *)      end; (* count *)      procedure draw (var g: graph; t: title);     var        max: integer;        i, j: integer;     begin        with g do        begin          page (output);         writeln (runname:75);          writeln;         max := 0;          for i := 0 to maxcounter do            if counter [i] > max then max := counter [i];          if max > 0 then          begin            for i := 0 to maxcounter do            begin              if i < 20 then write ('   ', t [i+1], ' ')             else write (' ':5);              if (i mod 5) = 0             then write (i * maximum / maxcounter:5:1, ' ')             else write (' ':6);              for j := 1 to counter [i] * maxcolumn div max do               write ('''');              writeln;           end; (* for *)           writeln; writeln;            writeln (count:10, ' total items');            if count <> 0 then           begin              writeln (highest:10:3, ' maximum');              writeln (sum/count:10:3, ' arithmetic mean');              writeln (sqrt (sumsq/count - sqr (sum/count)):10:3,                ' standard deviation');            end;         end; (* if *)        end; (* with *)      end; (* draw *)       procedure clear (var g: scatter; xmax, ymax: real);      var        i: integer;      begin        with g do        begin          count := 0;          sumx := 0;         sumy := 0;         xinc := xmax / (maxxscat);         yinc := ymax / (maxyscat);         for i := 0 to maxyscat do            marks [0][i] := false;          for i := 0 to maxxscat do            marks [i] := marks [0];        end;     end;  (* clear *)          procedure mark (var g: scatter; x, y: real);     begin        with g do        begin          count := count + 1;          sumx := sumx + x;          sumy := sumy + y;          marks [limit (x/xinc, maxxscat)]               [limit (y/yinc, maxyscat)] := true;       end;     end;  (* mark *)         procedure plot (var g: scatter; x, y: title);      var i, j, k: integer;      begin        page (output);       writeln (runname:75);        writeln;       with g do        for i := maxyscat downto 0 do        begin          k := maxyscat - i + 1;         if k <= 20 then write (' ', y [k])         else write (' ':2);          if (i mod 5) = 0 then write (i*yinc:9:3, ' ')          else write (' ':10);         for j := 0 to maxxscat do            if marks [j][i] then write ('*')            else write (' ');          writeln;       end;       writeln;       write (' ':6);       j := 0;        repeat         write (j * g.xinc:10:3);         j := j + 10;       until j > maxxscat;        writeln; writeln;        write (' ':12);        for k := 1 to 20 do write (x [k]:2);       writeln; writeln;        with g do          if count <> 0 then           writeln (              sumx / count: 9:3, ' mean ', x,              sumy / count: 9:3, ' mean ', y);     end;  (* plot *)         procedure routetable (n: nodenum);     var        l, z: integer;     begin        with s [n] do        begin          writeln (clock:7:3, ' routing at ', city);         for l := 1 to maxlevel do          begin            write (' ':10);            for z := 1 to maxorder do              if delay [l][z] <> 0 then               write (delay [l][z]:4, ' ', s [route [l][z]].city:8)             else               write (' ':13);            writeln;         end;       end;     end;  (* routetable *)       procedure simulate;  (* discrete simulator *)    var      thisevent,     nextevent,     lastevent,     freelist: link;  (* event queue *)      procedure alloc (var p: link);   begin      if freelist = nil      then (* allocate from pascal heap *)       begin          new (lastnew);         p := lastnew;        end      else  (* re-allocate from free list *)     begin        p := freelist;       freelist := freelist^.next;      end;   end; (* alloc *)      procedure free (p: link);    begin      p^.next := freelist;     freelist := p;   end; (* free *)       procedure queue (entry: link);     label 1;     var p, q: link;         begin        if trace.events then         writeln (' ',ord (entry):6 oct,' queued');       with entry^ do       if nextevent = nil       then  (* insert as only entry *)       begin          next := nil;         nextevent := entry;        end        else       begin          if timex < nextevent^.timex          then  (* insert at head *)         begin            next := nextevent;           nextevent := entry;          end          else  (* insert in middle, or end *)         begin            q := nextevent;            if lastevent <> nil then             if lastevent^.timex <= timex then                q := lastevent;            p := q^.next;            while p <> nil do            begin              if p^.timex > timex then goto 1;             q := p;              p := p^.next;            end; (* while *)       1:  next := q^.next;           q^.next := entry;          end;       end;     lastevent := entry;      end; (* queue *)      function dequeue (var head: link): link;     begin (* remove block from head of queue *)        dequeue := head;       head := head^.next;      end; (* dequeue *)         procedure propagate (n: nodenum);      var load, l, z: integer;       diff: real;        e: link;     begin        if dynamic then with s [n] do          if not updating then         begin            load := queuelength + 1; (*$t-*)   for l := 1 to maxlevel do            begin  (* look for changes *)              for z := 1 to maxorder do              begin                diff := (promise[l][z]-delay[l][z]-load)/(delay[l][z]+20);               updating := updating or (abs (diff) > 0.10);             end;           end;           if updating then           begin              for l := 1 to maxlevel do              begin                promise [l] := delay [l];              for z := 1 to maxorder do                  if promise[l][z] <> 0 then                   promise[l][z] := promise[l][z] + load;               promise[l][zip [l]] := load;             end; (*$t+*)     alloc (e);             with e^ do             begin  (* propagate promise to neighbors *)                timex := clock + 0.2;                name := update;                node := n;               queue (e);             end;             if tracing then              begin                writeln (clock:7:3, ' route broadcast from ', city:15,                 ' with load ', load:3, ' as follows:');                for l := 1 to maxlevel do                begin                  write (' ':7);                 for z := 1 to maxorder do write (promise [l][z]:4);               end;               writeln;             end; (* if *)            end;  (* if *)         end;  (* with, if *)     end;  (* propagate *)          procedure schedule (station: nodenum);     var        event: link;       i: 1..maxpath;       success: real;     begin        alloc (event);       with event^, s [station] do        begin          name := xmit;          node := station;         success := 1.0;          for i := 1 to lastpath do  (* compute interference *)            if s [path [i]].nextmsg <> nil then              success := success * (waittime / (xmittime + waittime));         timex := clock + xmittime            + (xmittime+waittime) * (1.0 / success - 1.0);         count (1.0 / success - 1.0, retrys);         count (clock - nextmsg^.queued, queuetime);          queuelength := queuelength - 1;          usecount := usecount +1;         usetime := usetime + timex - clock;          mark (queueing, timex, queuelength);         if tracing then            writeln (clock:7:3, ' message ', ord (nextmsg):6 oct,              ' sent from ', city:15,              ' after queueing ', clock - nextmsg^.queued:7:3,             ' and transmitting ', timex - clock:7:3);        end;       queue (event)      end; (* schedule *)       procedure queuemsg (m: link; r: nodenum);      begin        with s [r], m^ do        begin          next := nil;         queued := clock;         queuelength := queuelength + 1;          mark (queueing, clock, queuelength);         if nextmsg = nil then          begin            nextmsg := m;            schedule (r);          end          else           lastmsg^.next := m;          lastmsg := m;          propagate (r);       end (* with *)     end; (* queuemsg *)          function uniform: real;      begin (* uniform distribution from 0.0 to 1.0 *)       uniform := random (0.0);     end; (* uniform *)         function exponential: real;      begin  (* exponential distribution with mean of 1.0 *)       exponential := - ln (uniform)      end; (* exponential *)         function arrivalwait (n: nodenum): real;     var        t: real;     begin        if popbased then         t := interarrival * meanpop / s [n].population           - arrivaltime        else         t := interarrival - arrivaltime;       if t < 0 then t := 0;        arrivalwait := exponential * t + arrivaltime;      end;         procedure initialize;      var        e: link;       i: nodenum;      begin  (* initialize simulation *)       clock := 0.0;        eventcount := 0;       msgcount := 0;       updatecount := 0;        nextevent := nil;        freelist := nil;       for i := 1 to lastnode do        begin        alloc (e);       with e^ do       begin  (* initate arrivals *)          timex := clock + arrivalwait (i);          name := arrival;         node := i;         if timex <= lastarrival then           queue (e)          else         begin            free (e);            writeln (' no arrivals at ', s [i].city);          end;       end; (* with *)        end; (* for *)       alloc (e);       with e^ do       begin          timex := clock;          name := sample;          queue (e);       end;     end; (* initialize *)       procedure doxmit (sender: nodenum);      var        thismsg: link;       receiver: nodenum;       match: boolean;        i: 1..maxlevel;        total: real;      function nexthop (tozip: zipcode): nodenum;      var i: 1..maxlevel;      begin        i := 1;        while s [sender].zip [i] = tozip [i] do i := i+1;        nexthop := s [sender].route [i][tozip [i]];     end; (* nexthop *)        begin (* doxmit *)       with s [sender] do       begin          thismsg := dequeue (nextmsg);          if nextmsg <> nil then schedule (sender);          if trace.events or thismsg^.track then           writeln (' xmit ',ord (thismsg):6 oct,             ' on hop ', thismsg^.hopcount:1,             ' from ',city);          match := true;         with thismsg^ do           for i := 1 to maxlevel do              match := match and (destzip [i] = zip [i]);          if match then  (* at destination *)            with thismsg^ do             begin                total := clock - thismsg^.start;               mark (delivery, thismsg^.start, total);                count (total, transittime);                count (thismsg^.hopcount, hops);               if hopcount > 50 then                 writeln (' looping from ', start:7:3,                   ' to ', clock:7:3,                   ' hopping ', hopcount:2, ' times');               if trace.messages then                 writeln (' at destination ', city, total:7:3);               free (thismsg);                msgcount := msgcount - 1;              end          else (* en route *)          begin            receiver := nexthop (thismsg^.destzip);            if trace.messages then             writeln (' hop from ',city,'to ',s [receiver].city);           if plotting then            writeln (plotfil, clock:7:3, latatude, longitude,              s [receiver].latatude, s [receiver].longitude);          if s [receiver].queuelength < queuelimit             then             begin                if s [receiver].tracing then with thismsg^ do                  writeln (clock:7:3, ' message ', ord (thismsg):6 oct,                    ' received at ', s [receiver].city,                    ' from ', city:15,                   ' destined for ',                    destzip [1]:1, destzip [2]:1, destzip [3]:1);                queuemsg (thismsg,receiver);               with thismsg^ do                 hopcount := hopcount + 1;              end              else             begin                queuemsg (thismsg,sender);             end;         end;         propagate (sender);        end; (* with *)        free (thisevent);      end; (* doxmit *)          procedure doarrival (receiver: nodenum);     var        object: integer;       newmsg: link;        dest: integer;     begin        alloc (newmsg);        with s [receiver], newmsg^ do        begin          if trace.events then           writeln (' arrival ', ord (newmsg):6 oct, ' at ',city);          if popbased then         begin            object := trunc (uniform * totalpop);            dest := 0;           repeat             dest := dest + 1;              object := object - s [dest].population;            until object <= 0;         end          else           dest := trunc (lastnode*uniform)+1;          destzip := s [dest].zip;         start := clock;          track := abs (clock - 217.479) < 0.01;         hopcount := 0;         if s [receiver].queuelength < queuelimit           then           begin              queuemsg (newmsg,receiver);              msgcount := msgcount + 1;              if tracing then                writeln (clock:7:3, ' message ', ord (newmsg):6 oct,                 ' originated at ', city:15,                  ' destined for ',                  destzip [1]:1, destzip [2]:1, destzip [3]:1);            end            else           begin              writeln (clock:7:3, ' blocked arrival at ', city);             free (newmsg);           end;       end; (* with *)        thisevent^.timex := clock + arrivalwait (receiver);        if thisevent^.timex <= lastarrival then          queue (thisevent)        else         free (thisevent);      end; (* doarrival *)         procedure dosample;      const        interval = 1.0;      var i: nodenum;      begin        mark (routing, clock, 60/interval * updatecount/lastnode);       mark (backlog, clock, msgcount);       if ((round (clock) mod 10) = 0) and trace.tables then        begin          routetable (10);         routetable (169);        end;       if trace.samples then        begin          writeln;         writeln (clock:7:3, ' sample statistics');         writeln (eventcount:7, ' events processed');         writeln (updatecount:7, ' routing updates');         writeln (msgcount:7, ' messages in transit');          for i := 1 to lastnode do          begin            if (i mod 10) = 1 then writeln;            if s [i].nextmsg <> nil then             write (s [i].queuelength:3, ' ', s [i].city:8)           else             write (' ':12);          end;         writeln;       end;       eventcount := 0;       updatecount := 0;        thisevent^.timex := clock + interval;        if (clock > lastarrival) and (msgcount = 0)        then       begin          free (thisevent);        end        else queue (thisevent);      end; (* dosample *)          procedure doupdate (sender: nodenum);      var i, l, z: integer;        receiver: nodenum;       offer: delayvector;      change: boolean;     begin        for i := 1 to s [sender].lastpath do       begin          receiver := s [sender].path [i];         with s [receiver] do         begin            l := 1;            change := false; (*$t-*)   repeat             offer := s [sender].promise [l];            for z := 1 to maxorder do              begin                if offer [z] <> 0 then (* known region *)                if (offer [z] < delay [l][z])   (* better offer *)                  or (route [l][z] = sender) then   (* current dest *)                if s [sender].route [l][z] <> receiver then  (* no flip *)                  begin                    if tracing then                    if s [route [l][z]].tracing                     or s [sender].tracing then                     writeln (clock:7:3, ' route change at ', city:15,                        ' for ', l:2, z:2,                       ' from ', s [route [l][z]].city:15,                       ' to ', s [sender].city:15,                        ' improving by ', delay [l][z]-offer [z]:4);                    change := change or (delay [l][z] <> offer [z]);                    delay [l][z] := offer [z];                    route [l][z] := sender;                 end;             end;  (* for *)              l := l + 1;            until (s [sender].zip [l-1] <> zip [l-1]) or (l > maxlevel); (*$t+*)   if change then propagate (receiver);         end;  (* with *)       end;  (* for *)        s [sender].updating := false;        updatecount := updatecount + 1;        free (thisevent);      end;  (* doupdate *)         begin (* simulate *)     initialize;      while (nextevent <> nil) and (clock < maxclock) do     begin        thisevent := dequeue (nextevent);        if thisevent = lastevent then lastevent := nil;        clock := thisevent^.timex;       if trace.events then         write (clock:7:3,' minutes ',ord (thisevent):6 oct);       with thisevent^ do       case name of         xmit: doxmit (node);         arrival: doarrival (node);         sample: dosample;          update: doupdate (node);       end; (* case *)        eventcount := eventcount + 1;      end; (* while *)     while nextevent <> nil do      begin  (* print leftover events *)       thisevent := dequeue (nextevent);        write (thisevent^.timex:7:3, ' ', ord (thisevent):6 oct, ' ');       with thisevent^ do       case name of         xmit: with s [node], nextmsg^ do           writeln (' xmit ',            destzip [1]:2, destzip [2]:1, destzip [3]:1,             start:7:3, ' ', city);         arrival: writeln (' arrival ', s [node].city);         sample: writeln (' sample ');          update: writeln (' update ', s[node].city);        end;  (* case *)       free (thisevent);      end;  (* while *)    end; (* simulate *)        procedure report;  var    i: nodenum;    mode: array [boolean] of alfa;   throughput: scatter; begin    mode [false] := '  disabled';    mode [true] :=  '   enabled';    clear (throughput, 30, 100);   page (output);   writeln (runname:75);    writeln;   writeln (clock:10:3, ' minutes simulated');    writeln (lastarrival:10:3, ' last arrival');   writeln (interarrival:10:3, ' mean inter-arrival period');   writeln (arrivaltime:10:3, ' minimum inter-arrival period');   writeln (queuelimit:10, ' buffer limit');    writeln (mode [dynamic], ' dynamic routing');    writeln (mode [linked], ' trans-con data link');   writeln (mode [popbased], ' population based (',     totalpop:1, ') load');   writeln;   writeln;   writeln (' message counts and utilizations');    for i := 1 to lastnode do with s [i] do    begin      if (i mod 5) = 1 then writeln;     write (usecount:4, usetime/clock*100.0:6:1, ' ', city:15);     mark (throughput,        usecount / transittime.count * 100.0,        usetime / clock * 100.0);    end;   writeln;   plot (throughput,      'traffic share       ',      'radio utilization   '); end; (* report *)     begin (* main program *)   message ('  ');    message (runname);   message ('  ');    rewrite (plotfil);  readinput;   preset (retrys,10.0);    preset (queuetime, 10.0);    preset (transittime, 50.0);    preset (hops, 50);   clear (backlog, maxclock, 300.0);    clear (routing, maxclock, 100.0);    clear (delivery, maxclock, 50.0);    clear (queueing, maxclock, 50.0);    trace.messages := false;   trace.events := false;   trace.tables := false;   trace.samples := false;    simulate;    report;    draw (retrys, 'retransmissions     ');   draw (queuetime, 'queueing delay      ');    draw (transittime, 'transit time        ');    draw (hops, 'hop count           ');   plot (backlog,  'elapsed time        ',                    'messages in transit ');   plot (queueing, 'elapsed time        ',                    'message queue length');   plot (routing,  'sample time         ',                    'routing broadcasts  ');   plot (delivery, 'start time          ',                    'transit time        ');   page (output);   writeln (' heap allocated to ', ord (lastnew):6 oct);  end. 